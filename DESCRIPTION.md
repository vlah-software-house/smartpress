# **AI-Driven CMS Architecture Planning**

## **1\. Overview & Tech Stack**

* **Backend:** Go (Golang) \- using the standard net/http (or a minimalist router like Chi) for raw performance and high concurrency.  
* **Database:** PostgreSQL (recommended for production/relational data) or SQLite (for an ultra-fast setup and portability at the MVP stage).  
* **Frontend Admin:** HTMX (for dynamic interactions without page reloads), AlpineJS (for ephemeral client-side states, e.g., dropdowns, modals), and TailwindCSS (for rapid, systematic design).  
* **Public Rendering:** Go html/template powered by the database, heavily backed by an aggressive caching layer (Redis or In-Memory).  
* **AI Integration:** Gemini / OpenAI / Claude API for generating content and HTML/Tailwind code.

## **2\. System Architecture (Core Components)**

### **A. Database Engine (Simplified Schema)**

1. **Users/Roles:** For administration and access control.  
2. **Posts/Pages:** The actual content (Title, Slug, Content, Meta metadata).  
3. **Templates (AI-Generated):**  
   * id, name, type (header, footer, page, article\_loop).  
   * html\_content (The HTMX \+ Tailwind code generated by AI).  
   * version, is\_active.  
4. **Cache Invalidation Log:** To track when pages need to be regenerated.

### **B. Rendering Engine (Frontend Generator & Cache)**

* **How it works:** When a user requests /about-us, Go doesn't look for a physical .html file. It queries the database for the active "Page" template, injects the "About Us" content, and renders the HTML on the fly.  
* **The Caching System:**  
  * **Level 1 (Memory):** Compiled Go templates (\*template.Template) are kept in the Go server's RAM. They are only reloaded when a new template is saved in the DB.  
  * **Level 2 (Full Pages):** The final HTML response is saved in a Key-Value store (e.g., Redis or an internal map with sync.RWMutex) for unauthenticated GET requests.  
  * **Invalidation:** Any "Save" action in the admin panel purges the associated cache key.

## **3\. Administration Interface (The "Familiar" Ecosystem)**

* **Layout:** Fixed left sidebar (Dashboard, Posts, Pages, Media, AI Design, Settings), right content area. Exactly like WordPress, but blazingly fast.  
* **Technology:** Everything is powered by HTMX. Clicking on "Pages" triggers an hx-get="/admin/pages" and swaps only the right content area (hx-target="\#main-content"). Zero full page reloads.  
* **The Content Editor:**  
  * A custom or integrated WYSIWYG editor (e.g., Trix, Quill, or a custom block editor built with AlpineJS).  
  * **"AI Assistant" Button:** A sidebar or modal (AlpineJS) where the user can prompt: *"Rewrite this paragraph in a more professional tone"* or *"Generate 3 title ideas"*.

## **4\. AI Integration (Key Strengths)**

### **A. Content Assistance (The Editor's Copilot)**

* Autocomplete features.  
* Article structure generation based on a prompt.  
* Automatic SEO optimization (generating meta descriptions, suggesting keywords based on text).  
* Automatic tag extraction.

### **B. Frontend Generator (AI Theme Builder)**

This is the "Killer Feature" of the CMS.

* **The "Design" Interface:** A chat UI where the admin writes: *"I want a dark mode landing page, with a large hero section, text on the left, image on the right, and a green call-to-action button."*  
* **The Go Process:**  
  1. Go sends the prompt to the LLM, specifically requesting: *Valid HTML code, styled with TailwindCSS classes, no external CSS, including Go template variables (e.g., {{.Title}}, {{.Content}})*.  
  2. The response is parsed and validated (to ensure the Go templates are correct and don't trigger a panic).  
  3. Live preview using an iframe or a div with hx-post for instant rendering based on dummy data.  
  4. Saved to the DB in the Templates table. The cache system is automatically invalidated.

## **5\. Roadmap & Development Stages**

### **Phase 1: The Base & "The WordPress Feel" (MVP 1\)**

* Go server setup, router, DB structure (SQLite/PostgreSQL).  
* Create the Admin UI layout with Tailwind and Alpine (sidebar, HTMX navigation).  
* CRUD operations for Pages/Posts.  
* Basic text editor integration.

### **Phase 2: Dynamic Template Engine**

* The templates database table.  
* Custom parser that reads from the DB, compiles as a Go Template, and serves public pages.  
* Implementation of the In-Memory Cache layer.

### **Phase 3: The AI "Brain" (MVP 2\)**

* Integration with the LLM API.  
* Adding the text assistant to the page editor.  
* Creating the "AI Theme Builder" area \-\> generating HTML+Tailwind chunks, validation, and DB storage.

### **Phase 4: Polish & Performance**

* Cache optimization (partial invalidation strategies).  
* Security (XSS protection on AI-generated HTML).  
* Support for static assets (efficiently uploading and serving images).

## **6\. Anticipated Challenges & Solutions**

1. **Security of AI-generated templates:**  
   * *Solution:* The AI might hallucinate malicious code or broken template tags. Strict validation must be implemented (html/template in Go is safe by default against injections, but we must catch compilation errors with template.Must(...) before saving to the DB).  
2. **Managing CSS (Tailwind):**  
   * *Solution:* Since the AI uses arbitrary Tailwind classes generated *dynamically*, we either need to use Tailwind via CDN (in dev mode) OR integrate a server-side build script that compiles a minimal CSS file based on the classes saved in the DB upon every template update.
